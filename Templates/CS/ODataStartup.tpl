<CODEGEN_FILENAME>Startup.cs</CODEGEN_FILENAME>
<REQUIRES_CODEGEN_VERSION>5.4.6</REQUIRES_CODEGEN_VERSION>
<REQUIRES_USERTOKEN>API_DOCS_PATH</REQUIRES_USERTOKEN>
<REQUIRES_USERTOKEN>API_TITLE</REQUIRES_USERTOKEN>
<REQUIRES_USERTOKEN>MODELS_NAMESPACE</REQUIRES_USERTOKEN>
<REQUIRES_USERTOKEN>CONTROLLERS_NAMESPACE</REQUIRES_USERTOKEN>
<REQUIRES_USERTOKEN>OAUTH_API</REQUIRES_USERTOKEN>
<REQUIRES_USERTOKEN>OAUTH_SERVER</REQUIRES_USERTOKEN>
<REQUIRES_USERTOKEN>SERVER_HTTPS_PORT</REQUIRES_USERTOKEN>
;//****************************************************************************
;//
;// Title:       ODataStartup.tpl
;//
;// Type:        CodeGen Template
;//
;// Description: Creates a Startup class for an OData / Web API hosting environment
;//
;// Copyright (c) 2018, Synergex International, Inc. All rights reserved.
;//
;// Redistribution and use in source and binary forms, with or without
;// modification, are permitted provided that the following conditions are met:
;//
;// * Redistributions of source code must retain the above copyright notice,
;//   this list of conditions and the following disclaimer.
;//
;// * Redistributions in binary form must reproduce the above copyright notice,
;//   this list of conditions and the following disclaimer in the documentation
;//   and/or other materials provided with the distribution.
;//
;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;// POSSIBILITY OF SUCH DAMAGE.
;//
//*****************************************************************************
//
// Title:       Startup.cs
//
// Description: Startup class for an OData / Web API hosting environment
//
//*****************************************************************************
// WARNING: GENERATED CODE!
// This file was generated by CodeGen. Avoid editing the file if possible.
// Any changes you make will be lost of the file is re-generated.
//*****************************************************************************
//

using Harmony.AspNetCore;
using Harmony.AspNetCore.Context;
using Harmony.Core;
using Harmony.Core.Context;
using Harmony.Core.FileIO;
using Harmony.Core.Utility;
using Harmony.OData;
using Harmony.OData.Adapter;
<IF DEFINED_ENABLE_AUTHENTICATION>
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Authentication.JwtBearer;
</IF DEFINED_ENABLE_AUTHENTICATION>
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Abstractions;
using Microsoft.AspNetCore.Mvc.ApiExplorer;
using Microsoft.AspNetCore.StaticFiles;
using Microsoft.AspNet.OData;
using Microsoft.AspNet.OData.Extensions;
using Microsoft.AspNet.OData.Builder;
using Microsoft.AspNet.OData.Formatter;
using Microsoft.AspNet.OData.Routing;
using Microsoft.AspNet.OData.Routing.Conventions;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Microsoft.Extensions.Primitives;
<IF DEFINED_ENABLE_AUTHENTICATION>
<IF DEFINED_ENABLE_CUSTOM_AUTHENTICATION>
using Microsoft.IdentityModel.Tokens;
</IF DEFINED_ENABLE_CUSTOM_AUTHENTICATION>
</IF DEFINED_ENABLE_AUTHENTICATION>
using System;
using Microsoft.Net.Http.Headers;
using Microsoft.OData;
using Microsoft.OData.Edm;
using Microsoft.OData.UriParser;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using <CONTROLLERS_NAMESPACE>;
using <MODELS_NAMESPACE>;
<IF DEFINED_ENABLE_API_VERSIONING>
using Swashbuckle.AspNetCore.Swagger;
using Microsoft.OpenApi.Models;
</IF DEFINED_ENABLE_API_VERSIONING>

namespace <NAMESPACE>
{
    public partial class Startup
    {
        /// <summary>
        /// This property will be populated later by the default SelfHostEnvironment class.
        /// It wil contain a list of all of the logical names used to locate data files in the repository.
        /// This information can be useful if implementing a custom FileSpecResolver class, which is done
        /// in the Services Assembly, which is why the collection is defined here.
        /// </summary>
        public static List<string> LogicalNames;

        // Items provided by dependency injection
        public IHostingEnvironment _env;
        public IConfiguration _config;

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="env">HTTP hosting environment</param>
        /// <param name="config">Configuration data</param>
        public Startup(IHostingEnvironment env, IConfiguration config)
        {
            _env = env;
            _config = config;
        }

        /// <summary>
        /// This methoid is used to make services available to the application.
        /// These services are typically accessed via dependency injection in controller classes.
        /// The primary purpose of the ConfigureServices method is as a place to register
        /// implementations of types for services that are needed by the application.
        /// It is also used to configure any options related to those services.
        /// </summary>
        /// <param name="services">Collection of available services.</param>
        public void ConfigureServices(IServiceCollection services)
        {
            //-------------------------------------------------------
            //Enable logging

            var log_level = LogLevel.Error;
            var logical = Environment.GetEnvironmentVariable("ASPNETCORE_LOG_LEVEL");
            if (logical != null)
            {
                switch (logical.ToLower())
                {
                    case "0":
                    case "trace":
                        log_level = LogLevel.Trace;
                        break;
                    case "1":
                    case "debug":
                        log_level = LogLevel.Debug;
                        break;
                    case "2":
                    case "information":
                        log_level = LogLevel.Information;
                        break;
                    case "3":
                    case "warning":
                        log_level = LogLevel.Warning;
                        break;
                    case "4":
                    case "error":
                        log_level = LogLevel.Error;
                        break;
                    case "5":
                    case "critical":
                        log_level = LogLevel.Critical;
                        break;
                    case "6":
                    case "none":
                        log_level = LogLevel.None;
                        break;
                    default:
                        throw new Exception($"Invalid value for logical ASPNETCORE_LOG_LEVEL={logical}");
                }
            }

            services.AddLogging(builder => builder.SetMinimumLevel(log_level));

            //-------------------------------------------------------
            //Make AppSettings available as a service

            //Add an AppSettings service.
            //To get an instance from DI ask for an @IOptions< AppSettings >
            if (_config != null)
                services.AddOptions<AppSettings>().Validate(appSettingsInstance =>
                {
                    appSettingsInstance.ProcessEnvironmentVariables();
                    return true;
                }).Bind(_config.GetSection("AppSettings"));

            //-------------------------------------------------------
            //Load Harmony Core

            services.AddSingleton<IEdmBuilder, EdmBuilder>();
            services.AddSingleton<IFileChannelManager, FileChannelManager>();
            services.AddSingleton<IDataObjectProvider>(serviceProvider =>
            {
                //DataObjectProvider configuration
                var objectProvider = new DataObjectProvider(serviceProvider.GetService<IFileChannelManager>());
                <STRUCTURE_LOOP>
                objectProvider.AddDataObjectMapping<<StructureNoplural>>("<FILE_NAME>", <IF STRUCTURE_ISAM>FileOpenMode.UpdateIndexed</IF STRUCTURE_ISAM><IF STRUCTURE_RELATIVE>FileOpenMode.UpdateRelative</IF STRUCTURE_RELATIVE>);
                </STRUCTURE_LOOP>
                return objectProvider;
            });
            services.AddDbContextPool<<MODELS_NAMESPACE>.DbContext>((sp, opts) =>
            {
                //DbContext configuration
                HarmonyDbContextOptionsExtensions.UseHarmonyDatabase(opts, sp.GetService<IDataObjectProvider>());
            });

            //-------------------------------------------------------
            //Load OData and ASP.NET


        <IF DEFINED_ENABLE_API_VERSIONING>
            services.AddApiVersioning(vOptions =>
            {
                vOptions.ReportApiVersions = true;
                //vOptions.AssumeDefaultVersionWhenUnspecified = true;
                vOptions.RouteConstraintName = "apiVersion";
                vOptions.DefaultApiVersion = ApiVersion.Parse("1");
            });
            services.AddOData().EnableApiVersioning();
            services.AddODataApiExplorer(vOptions =>
            {
                // add the versioned api explorer, which also adds IApiVersionDescriptionProvider service
                // note: the specified format code will format the version as "'v'major[.minor][-status]"
                vOptions.GroupNameFormat = "'v'V";
                vOptions.SubstitutionFormat = "V";

                // note: this option is only necessary when versioning by url segment. the SubstitutionFormat
                // can also be used to control the format of the API version in route templates
                vOptions.SubstituteApiVersionInUrl = true;
            });
        <ELSE>
            services.AddSingleton<ODataUriResolver>(serviceProvider =>
            {
                var model = EdmBuilder.GetEdmModel(serviceProvider);
                model = EdmBuilder.GetEdmModel(serviceProvider);
                return new UnqualifiedAltKeyUriResolver(model) <IF NOT_DEFINED_ENABLE_CASE_SENSITIVE_URL>{ EnableCaseInsensitive = true }</IF NOT_DEFINED_ENABLE_CASE_SENSITIVE_URL>;
            });

            services.AddOData();
        </IF DEFINED_ENABLE_API_VERSIONING>

            //-------------------------------------------------------
            //Load our workaround for the fact that OData alternate key support is messed up right now!

            //Note: this fails in Unit Testing
            services.AddSingleton<IPerRouteContainer, HarmonyPerRouteContainer>();
            <IF DEFINED_ENABLE_API_VERSIONING>

            services.AddSwaggerGen(options =>
            {
                // resolve the IApiVersionDescriptionProvider service
                // note: that we have to build a temporary service provider here because one has not been created yet
                var provider = (IApiVersionDescriptionProvider) services.BuildServiceProvider()
                    .GetRequiredService(typeof(IApiVersionDescriptionProvider));

                // add a swagger document for each discovered API version
                // note: you might choose to skip or document deprecated API versions differently
                foreach (var description in provider.ApiVersionDescriptions)
                {
                    var info = new OpenApiInfo()
                    {
                        Title = "Harmony Core Sample API " + description.ApiVersion.ToString(),
                        Version = description.ApiVersion.ToString(),
                        Description =
                            "This environment presents an example of using Harmony Core to expose a collection of RESTful Web Service endpoints that allow you to interact with a small sample dataset.",
                        Contact = new OpenApiContact()
                            {Name = "Jodah Veloper", Email = "jodah.veloper@synergexpsg.com"},
                        TermsOfService = new Uri("https://opensource.org/licenses/BSD-2-Clause"),
                        License = new OpenApiLicense()
                            {Name = "BSD 2-Clause", Url = new Uri("https://opensource.org/licenses/BSD-2-Clause")}
                    };

                    options.SwaggerDoc(description.GroupName, info);
                }

                // add a custom operation filter which sets default values
                //options.OperationFilter<SwaggerDefaultValues>();

                // integrate xml comments
                //options.IncludeXmlComments( XmlCommentsFilePath );
            });
            <ELSE>
                <IF DEFINED_ENABLE_SWAGGER_DOCS>

            services.AddSwaggerGen();
                </IF DEFINED_ENABLE_SWAGGER_DOCS>
            </IF DEFINED_ENABLE_API_VERSIONING>

            var mvcBuilder = services.AddMvcCore(op =>
                {
                    var mediaTypeName = "application/prs.mock-odata";
                    var sseg = new StringSegment(mediaTypeName);
                    op.EnableEndpointRouting = false;
                    foreach (var formatter in op.OutputFormatters.OfType<ODataOutputFormatter>()
                        .Where(it => !it.SupportedMediaTypes.Any()))
                    {
                        formatter.SupportedMediaTypes.Add(new MediaTypeHeaderValue(sseg));
                    }

                    foreach (var iformatter in op.InputFormatters.OfType<ODataInputFormatter>()
                        .Where(it => !it.SupportedMediaTypes.Any()))
                    {
                        iformatter.SupportedMediaTypes.Add(new MediaTypeHeaderValue(sseg));
                    }

                    op.MaxIAsyncEnumerableBufferLimit = int.MaxValue;
                })
                .SetCompatibilityVersion(CompatibilityVersion.Version_3_0)
                .AddDataAnnotations() // Enable data annotations
                .AddNewtonsoftJson() // For PATCH
            <IF DEFINED_ENABLE_SWAGGER_DOCS>
                .AddApiExplorer() // Swagger UI
            </IF DEFINED_ENABLE_SWAGGER_DOCS>
                .AddApplicationPart(typeof(IsolatedMethodsBase).Assembly);

        <IF DEFINED_ENABLE_AUTHENTICATION>
          <IF DEFINED_ENABLE_CUSTOM_AUTHENTICATION>            
            services.AddAuthentication(options =>
            {
                options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
                options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
            }).AddJwtBearer("Bearer", o =>
            {
                o.IncludeErrorDetails = true;
                o.ClaimsIssuer = "<CUSTOM_JWT_ISSUER>";
                o.Audience = "<CUSTOM_JWT_AUDIENCE>";
                o.TokenValidationParameters = new TokenValidationParameters()
                {
                    ValidateIssuer = true,
                    ValidIssuer = "<CUSTOM_JWT_ISSUER>",
                    ValidateAudience = true,
                    ValidAudience = "<CUSTOM_JWT_AUDIENCE>",
                    ValidateIssuerSigningKey = true,
                    IssuerSigningKey = new SymmetricSecurityKey(<OAUTH_KEY>)
                };
            <IF DEFINED_ENABLE_SIGNALR>

                var jwtEvents = new JwtBearerEvents();
                o.Events = jwtEvents;
                jwtEvents.OnMessageReceived = (context) =>
                {
                    var accessToken = context.Request.Query["access_token"];

                    // If the request is for our hub...
                    var path = context.HttpContext.Request.Path;
                    if (!string.IsNullOrEmpty(accessToken) && path.StartsWithSegments(new PathString("<SIGNALR_PATH>")))
                    {
                        // Read the token out of the query string
                        context.Token = accessToken;
                    }
                    return Task.CompletedTask;
                };
            </IF DEFINED_ENABLE_SIGNALR>
            });
            mvcBuilder.AddAuthorization(options => {
                options.DefaultPolicy = new AuthorizationPolicyBuilder(JwtBearerDefaults.AuthenticationScheme)
                    .RequireAuthenticatedUser().Build();
            });
          <ELSE>
            //-------------------------------------------------------
            //Enable authentication and authorization

            services.AddAuthentication(options =>
            {
                options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
                options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
            }).AddIdentityServerAuthentication(options => {
                options.Authority = "<OAUTH_SERVER>";
                options.RequireHttpsMetadata = false;
                options.ApiName = "<OAUTH_API>";
            });
            mvcBuilder.AddAuthorization(options =>
            {
                options.DefaultPolicy = new AuthorizationPolicyBuilder(JwtBearerDefaults.AuthenticationScheme)
                    .RequireAuthenticatedUser().Build();
            });
          </IF DEFINED_ENABLE_CUSTOM_AUTHENTICATION>
        </IF DEFINED_ENABLE_AUTHENTICATION>

            //-------------------------------------------------------
            //Enable HTTP redirection to HTTPS

            services.AddHttpsRedirection(options =>
            {
                options.RedirectStatusCode = StatusCodes.Status307TemporaryRedirect;
                options.HttpsPort = 8086;
            });

        <IF DEFINED_ENABLE_IIS_SUPPORT>
            //-------------------------------------------------------
            //Enable support for hosting in IIS

            services.Configure<IISOptions>(options => options.ForwardClientCertificate = false);

        </IF DEFINED_ENABLE_IIS_SUPPORT>
        <IF DEFINED_ENABLE_CORS>
            //-------------------------------------------------------
            //Add "Cross Origin Resource Sharing" (CORS) support

            services.AddCors();

        </IF DEFINED_ENABLE_CORS>
            //If there is a ConfigureServicesCustom method, call it
            ConfigureServicesCustom(services);
        }

        private IDisposable AppSettingsMonitor;

        /// <summary>
        /// This method is used to configure the ASP.NET WebApi request pipeline.
        /// </summary>
        /// <param name="app">IApplicationBuilder component that configures the request pipeline by having middleware added to it.</param>
        /// <param name="env">IHostingEnvironment that exposes information about the environment that is hosting the application.</param>
        public void Configure(IApplicationBuilder app, IHostingEnvironment env,
            IApiVersionDescriptionProvider versionProvider)
        {
            //-------------------------------------------------------
            //Configure the AppSettings environment

            var optionsMonitorObj =
                ServiceProviderServiceExtensions.GetService<IOptionsMonitor<AppSettings>>(app.ApplicationServices);
            AppSettingsMonitor = optionsMonitorObj.OnChange((opts, name) => opts.ProcessEnvironmentVariables());
            var settings = ServiceProviderServiceExtensions.GetService<IOptions<AppSettings>>(app.ApplicationServices)
                .Value;

            //-------------------------------------------------------
            //Configure development and production specific components

            if (env.IsDevelopment())
            {
                var loggerFactory = app.ApplicationServices.GetRequiredService<ILoggerFactory>();
                app.UseDeveloperExceptionPage();
                var hc_log_level = Harmony.Core.Interface.LogLevel.Debug;
                var logical = Environment.GetEnvironmentVariable("ASPNETCORE_LOG_LEVEL");
                if (logical != null)
                {
                    switch (logical.ToLower())
                    {
                        case "0":
                        case "trace":
                            hc_log_level = Harmony.Core.Interface.LogLevel.Trace;
                            break;
                        case "1":
                        case "debug":
                            hc_log_level = Harmony.Core.Interface.LogLevel.Debug;
                            break;
                        case "2":
                        case "information":
                            hc_log_level = Harmony.Core.Interface.LogLevel.Info;
                            break;
                        case "3":
                        case "warning":
                            hc_log_level = Harmony.Core.Interface.LogLevel.Warning;
                            break;
                        case "4":
                        case "error":
                            hc_log_level = Harmony.Core.Interface.LogLevel.Error;
                            break;
                        case "5":
                        case "critical":
                            hc_log_level = Harmony.Core.Interface.LogLevel.Critical;
                            break;
                        default:
                            throw new Exception($"Invalid value for logical HARMONY_CORE_LOG_LEVEL={logical}");
                    }
                }
                else
                {
                    //Enable HTTP Strict Transport Security Protocol (HSTS)
                    //
                    //You need to research this and know what you are doing with this. Here's a starting point:
                    //https://docs.microsoft.com/en-us/aspnet/core/security/enforcing-ssl?view=aspnetcore-2.1&tabs=visual-studio
                    //
                    //app.UseHsts()
                }

                DebugLogSession.Logging = new AspNetCoreDebugLogger(loggerFactory.CreateLogger("HarmonyCore"))
                    {Level = hc_log_level};
                app.UseLogging(DebugLogSession.Logging);
            }

            //-------------------------------------------------------
            //Enable HTTP redirection to HTTPS

            app.UseHttpsRedirection();

        <IF DEFINED_ENABLE_AUTHENTICATION>
            //-------------------------------------------------------
            //Enable the authentication middleware

            app.UseAuthentication();

        </IF DEFINED_ENABLE_AUTHENTICATION>
            //-------------------------------------------------------
            //Configure the MVC & OData environments

        <IF DEFINED_ENABLE_CORS>
            //-------------------------------------------------------
            //Add "Cross Origin Resource Sharing" (CORS) support

            app.UseCors(builder => 
            {
                builder.AllowAnyOrigin()
                    .AllowAnyMethod()
                    .AllowAnyHeader();
            });

        </IF DEFINED_ENABLE_CORS>
            //-------------------------------------------------------
            //Enable MVC

            //If there is a ConfigureCustomBeforeMvc method, call it
            ConfigureCustomBeforeMvc(app, env);

            app.UseMvc(builder =>
            {
            <IF NOT_DEFINED_ENABLE_API_VERSIONING>
                var model = EdmBuilder.GetEdmModel(app.ApplicationServices);

            </IF NOT_DEFINED_ENABLE_API_VERSIONING>
                //Enable support for dependency injection into controllers
                builder.EnableDependencyInjection(containerBuilder =>
                    containerBuilder.AddService(Microsoft.OData.ServiceLifetime.Singleton,
                        s => app.ApplicationServices.GetRequiredService<ODataUriResolver>()));

                //Configure the default OData route
            <IF DEFINED_ENABLE_API_VERSIONING>
                var versionedModels = EdmBuilder.EdmVersions
                    .Select(versionNumber => EdmBuilder.GetEdmModel(app.ApplicationServices, versionNumber)).ToArray();
                builder.MapVersionedODataRoutes("<SERVER_BASE_PATH>", "<SERVER_BASE_PATH>/v{version:apiVersion}", versionedModels,
                    containerBuilder =>
                    {
                        var containerBuilderType = containerBuilder.GetType();
                        var servicesField = containerBuilderType.GetField("services",
                            System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
                        var serviceDescriptors = ((IEnumerable) servicesField.GetValue(containerBuilder))
                            .OfType<ServiceDescriptor>();
                        var versionedModelDescriptor =
                            serviceDescriptors.Last(descriptor => descriptor.ServiceType == typeof(IEdmModel));
                        var versionedModel = versionedModelDescriptor.ImplementationInstance ??
                                             versionedModelDescriptor.ImplementationFactory(app.ApplicationServices);
                        containerBuilder.AddService<IEdmModel>(Microsoft.OData.ServiceLifetime.Scoped,
                            sp => new RefEdmModel {RealModel = (versionedModel as IEdmModel)});
                        containerBuilder.AddService<ODataUriResolver>(Microsoft.OData.ServiceLifetime.Singleton,
                            sp => new UnqualifiedAltKeyUriResolver(versionedModel as IEdmModel)
                                {EnableCaseInsensitive = true});
                        containerBuilder.AddService<IODataPathTemplateHandler, PathTemplateHandler>(Microsoft.OData
                            .ServiceLifetime.Singleton);
                        containerBuilder.AddService<IODataPathHandler, PathTemplateHandler>(Microsoft.OData
                            .ServiceLifetime.Singleton);
                    },
                    configContext =>
                    {
                        configContext.RoutingConventions.Insert(1, new HarmonySprocRoutingConvention());
                        configContext.RoutingConventions.Insert(1, new AdapterRoutingConvention());
                    });
            <ELSE>
                builder.MapODataServiceRoute("<SERVER_BASE_PATH>", "<SERVER_BASE_PATH>", containerBuilder =>
                    {
                        containerBuilder.AddService<IEdmModel>(Microsoft.OData.ServiceLifetime.Scoped, sp => new RefEdmModel() { RealModel = EdmBuilder.GetEdmModel(sp) });
                        containerBuilder.AddService<IEnumerable<IODataRoutingConvention>>(Microsoft.OData.ServiceLifetime.Singleton, configContext =>
                        {
                            var routeList = ODataRoutingConventions.CreateDefaultWithAttributeRouting("<SERVER_BASE_PATH>", builder);
                        <IF DEFINED_ENABLE_SPROC>
                            routeList.Insert(0, new HarmonySprocRoutingConvention());
                        </IF DEFINED_ENABLE_SPROC>
                        <IF DEFINED_ENABLE_ADAPTER_ROUTING>
                            routeList.Insert(0, new AdapterRoutingConvention());
                        </IF DEFINED_ENABLE_ADAPTER_ROUTING>
                            return routeList;
                        });
                    });
            </IF DEFINED_ENABLE_API_VERSIONING>

                //---------------------------------------------------
                //Enable optional OData features

            <IF DEFINED_ENABLE_SELECT>
                //Enable $select expressions to select properties returned
                builder.Select();

            </IF DEFINED_ENABLE_SELECT>
            <IF DEFINED_ENABLE_FILTER>
                //Enable $filter expressions to filter rows returned
                builder.Filter();

            </IF DEFINED_ENABLE_FILTER>
            <IF DEFINED_ENABLE_ORDERBY>
                //Enable $orderby expressions to custom sort results
                builder.OrderBy();

            </IF DEFINED_ENABLE_ORDERBY>
            <IF DEFINED_ENABLE_COUNT>
                //Enable /$count endpoints
                builder.Count();

            </IF DEFINED_ENABLE_COUNT>
            <IF DEFINED_ENABLE_RELATIONS>
                //Enable $expand expressions to expand relations
                builder.Expand();

            </IF DEFINED_ENABLE_RELATIONS>
            <IF DEFINED_ENABLE_TOP>
                //Specify the maximum rows that may be returned by $top expressions
                builder.MaxTop(100);
            </IF DEFINED_ENABLE_TOP>
            });

            //-------------------------------------------------------
            //Configure the web server to serve static files

            //Support default files (index.html, etc.)
            app.UseDefaultFiles();

        <IF DEFINED_ENABLE_API_VERSIONING>
            //Support serving static files
            app.UseStaticFiles();

        <ELSE>
            //Add a media type for YAML files
            var provider = new FileExtensionContentTypeProvider();
            provider.Mappings[".yaml"] = "text/yaml";
            var sfoptions = new StaticFileOptions();
            sfoptions.ContentTypeProvider = provider;
            //Support serving static files
            app.UseStaticFiles(sfoptions);

        </IF DEFINED_ENABLE_API_VERSIONING>
        <IF DEFINED_ENABLE_API_VERSIONING>
            //-------------------------------------------------------
            //Configure and enable API versioning

            app.UseSwagger();
            app.UseSwaggerUI(config =>
            {
                config.RoutePrefix = "api-docs";
                foreach (var description in versionProvider.ApiVersionDescriptions)
                {
                    config.SwaggerEndpoint("/swagger/" + description.GroupName + "/swagger.json",
                        description.GroupName.ToUpperInvariant());
                }
            });

        <ELSE>
            <IF DEFINED_ENABLE_SWAGGER_DOCS>
            //-------------------------------------------------------
            //Configure and enable SwaggerUI

            app.UseSwagger();
            app.UseSwaggerUI(config => 
            {
                config.SwaggerEndpoint("/SwaggerFile.yaml", "<API_TITLE>");
                config.RoutePrefix = "<API_DOCS_PATH>";
                config.DocumentTitle = "<API_TITLE>";
            });

            </IF DEFINED_ENABLE_SWAGGER_DOCS>
        </IF DEFINED_ENABLE_API_VERSIONING>
            //If there is a ConfigureCustom method, call it
            ConfigureCustom(app, env);
        }

        #region "Partial method extensibility points"

        /// <summary>
        /// Declare the ConfigueServicesCustom partial method.
        /// Developers can implement this method in a partial class to provide custom services.
        /// </summary>
        /// <param name="services"></param>
        partial void ConfigureServicesCustom(IServiceCollection services);

        /// <summary>
        /// Declare the ConfigueCustom partial method
        /// Developers can implement this method in a partial class to provide custom configuration.
        /// </summary>
        /// <param name="app"></param>
        /// <param name="env"></param>
        partial void ConfigureCustom(IApplicationBuilder app, IHostingEnvironment env);

        /// <summary>
        /// Declare the ConfigueCustom partial method called immediately before AddMvc
        /// Developers can implement this method in a partial class to provide custom configuration.
        /// </summary>
        /// <param name="app"></param>
        /// <param name="env"></param>
        partial void ConfigureCustomBeforeMvc(IApplicationBuilder app, IHostingEnvironment env);

        #endregion
    }
}