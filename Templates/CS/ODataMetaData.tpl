<CODEGEN_FILENAME><StructureNoplural>MetaData.cs</CODEGEN_FILENAME>
<REQUIRES_CODEGEN_VERSION>5.4.6</REQUIRES_CODEGEN_VERSION>
;//****************************************************************************
;//
;// Title:       ODataMetaData.tpl
;//
;// Type:        CodeGen Template
;//
;// Description: Template to define meta data associated with a data model
;//
;// Copyright (c) 2012, Synergex International, Inc. All rights reserved.
;//
;// Redistribution and use in source and binary forms, with or without
;// modification, are permitted provided that the following conditions are met:
;//
;// * Redistributions of source code must retain the above copyright notice,
;//   this list of conditions and the following disclaimer.
;//
;// * Redistributions in binary form must reproduce the above copyright notice,
;//   this list of conditions and the following disclaimer in the documentation
;//   and/or other materials provided with the distribution.
;//
;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;// POSSIBILITY OF SUCH DAMAGE.
;//
//*****************************************************************************
//
// Title:       <StructureNoplural>MetaData.cs
//
// Description: Defines meta data associated with a <StructureNoplural> model.
//
//*****************************************************************************
// WARNING: GENERATED CODE!
// This file was generated by CodeGen. Avoid editing the file if possible.
// Any changes you make will be lost of the file is re-generated.
//*****************************************************************************

using System;
using System.Collections.Generic;
using System.Text;
using Harmony.Core;
using Harmony.Core.Converters;
using Synergex.SynergyDE;

namespace <NAMESPACE>
{
    /// <summary>
    /// Exposes metadata relating to the <StructureNoplural> model class.
    /// </summary>
    public partial class <StructureNoplural>Metadata : Dbl.<StructureNoplural>MetadataBase
    {
        /// <summary>
        /// Constructs an new <StructureNoplural>Metadata object.
        /// </summary>
        public <StructureNoplural>Metadata()
        {
            // Define structure name and size
            RPSStructureName = "<STRUCTURE_NOALIAS>";
            RPSStructureSize = Dbl.<StructureNoplural>Base.Get<StructureNoplural>Size();

            // Define fields
<FIELD_LOOP>
  <IF STRUCTURE_RELATIVE>
            AddFieldInfo("RecordNumber", "INTEGER", 4, 0, 0, false);
  </IF STRUCTURE_RELATIVE>
  <IF CUSTOM_NOT_HARMONY_EXCLUDE>
    <IF HARMONYCORE_CUSTOM_FIELD>
            AddFieldInfo("<FieldSqlname>", "<FIELD_TYPE_NAME>", <FIELD_SIZE>, <FIELD_POSITION>, 0<FIELD_PRECISION>, false, m<FieldSqlname>Formatter);
    <ELSE>
      <IF DATEORTIME>
            AddFieldInfo("<FieldSqlname>", "<FIELD_TYPE_NAME>", <FIELD_SIZE>, <FIELD_POSITION>, 0<FIELD_PRECISION>, false, m<FieldSqlname>Formatter);
      <ELSE>
        <IF CUSTOM_HARMONY_AS_STRING>
            AddFieldInfo("<FieldSqlname>", "<FIELD_TYPE_NAME>", <FIELD_SIZE>, <FIELD_POSITION>, 0<FIELD_PRECISION>, false, m<FieldSqlname>Formatter);
        <ELSE>
            AddFieldInfo("<FieldSqlname>", "<FIELD_TYPE_NAME>", <FIELD_SIZE>, <FIELD_POSITION>, 0<FIELD_PRECISION>, false);
        </IF CUSTOM_HARMONY_AS_STRING>
      </IF DATEORTIME>
    </IF HARMONYCORE_CUSTOM_FIELD>
  </IF CUSTOM_NOT_HARMONY_EXCLUDE>
</FIELD_LOOP>

<IF DEFINED_ENABLE_RELATIONS>
  <IF STRUCTURE_RELATIONS>
    <COUNTER_1_RESET>
    <RELATION_LOOP_RESTRICTED>
      <COUNTER_1_INCREMENT>
        <IF COUNTER_1_EQ_1>

            // Define relations
        </IF>
        <IF MANY_TO_ONE_TO_MANY>
            AddFieldInfo("<HARMONYCORE_RELATION_NAME>", "DATAOBJECT", 0, 0, 0, false);
        </IF MANY_TO_ONE_TO_MANY>
;//
        <IF ONE_TO_ONE_TO_ONE>
            AddFieldInfo("<HARMONYCORE_RELATION_NAME>", "DATAOBJECT", 0, 0, 0, false);
        </IF ONE_TO_ONE_TO_ONE>
;//
        <IF ONE_TO_ONE>
            AddFieldInfo("<HARMONYCORE_RELATION_NAME>", "DATAOBJECT", 0, 0, 0, false);
        </IF ONE_TO_ONE>
;//
        <IF ONE_TO_MANY_TO_ONE>
            AddFieldInfo("<HARMONYCORE_RELATION_NAME>", "COLLECTION", 0, 0, 0, false);
        </IF ONE_TO_MANY_TO_ONE>
;//
        <IF ONE_TO_MANY>
            AddFieldInfo("<HARMONYCORE_RELATION_NAME>", "COLLECTION", 0, 0, 0, false);
        </IF ONE_TO_MANY>
        
    </RELATION_LOOP_RESTRICTED>

    <COUNTER_1_RESET>
    <RELATION_LOOP_RESTRICTED>
      <COUNTER_2_RESET>
      <FROM_KEY_SEGMENT_LOOP>
        <IF SEG_TYPE_LITERAL>
         <COUNTER_1_INCREMENT>
         <IF COUNTER_1_EQ_1>
            // Define literal key segments in relation "from" keys
         </IF>
            AddFieldInfo("<RelationFromkey>Literal<COUNTER_2_INCREMENT><COUNTER_2_VALUE>", "TAG_LITERAL", 0, 0, 0, false, null,"<SEGMENT_LITVAL>");
        </IF SEG_TYPE_LITERAL>
      </FROM_KEY_SEGMENT_LOOP>
    </RELATION_LOOP_RESTRICTED>
  </IF STRUCTURE_RELATIONS>
</IF DEFINED_ENABLE_RELATIONS>

<IF STRUCTURE_ISAM>
  <COUNTER_1_RESET>
  <KEY_LOOP>
    <SEGMENT_LOOP>
      <COUNTER_1_INCREMENT>
        <IF COUNTER_1_EQ_1>
            // Define all fields that are associated wity key segments
        </IF>
            AddKeyInfo(<KEY_NUMBER>, "<FieldSqlname>");
    </SEGMENT_LOOP>
  </KEY_LOOP>
</IF STRUCTURE_ISAM>
<IF STRUCTURE_RELATIVE>
  <COUNTER_1_INCREMENT>
    <IF COUNTER_1_EQ_1>
            // Define all fields that are associated wity key segments
    </IF>
            AddKeyInfo(0, "recordNumber");
</IF STRUCTURE_RELATIVE>

            // Define the composition of access keys
<IF STRUCTURE_ISAM>
  <KEY_LOOP>
            var <KeyName>_KeyParts = new FieldDataDefinition[<KEY_SEGMENTS>];
    <SEGMENT_LOOP>
      <IF SEG_TYPE_LITERAL>
            <KeyName>_KeyParts[<SEGMENT_NUMBER> - 1] = AddFieldInfo("<KEY_NAME>Literal<SEGMENT_NUMBER>", "TAG_LITERAL", <SEGMENT_LENGTH>, 0, 0, false, null,"<SEGMENT_LITVAL>");
      <ELSE>
            <KeyName>_KeyParts[<SEGMENT_NUMBER> - 1] = GetFieldByName("<FieldSqlname>");
      </IF SEG_TYPE_LITERAL>
    </SEGMENT_LOOP>
            AddFieldInfo("KEY_<KEY_NAME>", "COMPOSITE", 0, 0, 0, false, null, null, <KeyName>_KeyParts);

  </KEY_LOOP>
  <COUNTER_1_RESET>
  <FOREIGN_KEY_LOOP>
    <COUNTER_1_INCREMENT>
      <IF COUNTER_1_EQ_1>
            // Define the composition of foreign keys
      </IF>

            var <KeyName>_KeyParts = new FieldDataDefinition[<KEY_SEGMENTS>];
      <SEGMENT_LOOP>
        <IF SEG_TYPE_LITERAL>
            <KeyName>_KeyParts[<SEGMENT_NUMBER> - 1] = AddFieldInfo("<KEY_NAME>Literal<SEGMENT_NUMBER>", "TAG_LITERAL", <SEGMENT_LENGTH>, 0, 0, false, null,"<SEGMENT_LITVAL>");
        <ELSE>
            <KeyName>_KeyParts[<SEGMENT_NUMBER> - 1] = GetFieldByName("<FieldSqlname>");
        </IF SEG_TYPE_LITERAL>
      </SEGMENT_LOOP>
            AddFieldInfo("KEY_<KEY_NAME>", "COMPOSITE", 0, 0, 0, false, null, null, <KeyName>_KeyParts);
  </FOREIGN_KEY_LOOP>
</IF STRUCTURE_ISAM>

            //If we have an InitializeCustomFields method then call it.
            InitializeCustomFields();

        }

        /// <summary>
        /// Returns a new <StructureNoplural> object containing data from a record and a GRFA.
<IF DEFINED_ENABLE_RELATIONS>
  <IF STRUCTURE_RELATIONS>
        /// The related data properties (<RELATION_LOOP_RESTRICTED><IF MANY_TO_ONE_TO_MANY><HARMONYCORE_RELATION_NAME></IF MANY_TO_ONE_TO_MANY><IF ONE_TO_ONE><HARMONYCORE_RELATION_NAME></IF ONE_TO_ONE><IF ONE_TO_MANY_TO_ONE><HARMONYCORE_RELATION_NAME></IF ONE_TO_MANY_TO_ONE><IF ONE_TO_MANY><HARMONYCORE_RELATION_NAME></IF ONE_TO_MANY><,and></RELATION_LOOP_RESTRICTED>) will not be populated.
  </IF STRUCTURE_RELATIONS>
</IF DEFINED_ENABLE_RELATIONS>
        /// </summary>
        /// <param name="dataArea">The record containing the data for the new <StructureNoplural> object.</param>
        /// <param name="grfa">The GRFA associated with the current state of the data.</param>
        /// <returns></returns>
        public override DataObjectBase MakeNew(AlphaDesc dataArea, AlphaDesc grfa)
        {
            return new <StructureNoplural>(dataArea, grfa);
        }

        /// <summary>
        /// Returns a new <StructureNoplural> object containing data from a record and a GRFA.
<IF DEFINED_ENABLE_RELATIONS>
  <IF STRUCTURE_RELATIONS>
        /// The related data properties (<RELATION_LOOP_RESTRICTED><IF MANY_TO_ONE_TO_MANY><HARMONYCORE_RELATION_NAME></IF MANY_TO_ONE_TO_MANY><IF ONE_TO_ONE><HARMONYCORE_RELATION_NAME></IF ONE_TO_ONE><IF ONE_TO_MANY_TO_ONE><HARMONYCORE_RELATION_NAME></IF ONE_TO_MANY_TO_ONE><IF ONE_TO_MANY><HARMONYCORE_RELATION_NAME></IF ONE_TO_MANY><,and></RELATION_LOOP_RESTRICTED>) will be populated.
  </IF STRUCTURE_RELATIONS>
</IF DEFINED_ENABLE_RELATIONS>
        /// </summary>
        /// <param name="dataArea">The record containing the data for the new <StructureNoplural> object.</param>
        /// <param name="grfa">The GRFA associated with the current state of the data.</param>
        /// <param name="joinedObjects">Data to allow the related data properties <IF DEFINED_ENABLE_RELATIONS><IF STRUCTURE_RELATIONS>(<RELATION_LOOP_RESTRICTED><IF MANY_TO_ONE_TO_MANY><HARMONYCORE_RELATION_NAME></IF MANY_TO_ONE_TO_MANY><IF ONE_TO_ONE><HARMONYCORE_RELATION_NAME></IF ONE_TO_ONE><IF ONE_TO_MANY_TO_ONE><HARMONYCORE_RELATION_NAME></IF ONE_TO_MANY_TO_ONE><IF ONE_TO_MANY><HARMONYCORE_RELATION_NAME></IF ONE_TO_MANY><,and></RELATION_LOOP_RESTRICTED>) </IF STRUCTURE_RELATIONS></IF DEFINED_ENABLE_RELATIONS>to be populated.</param>
        /// <returns></returns>
        public override DataObjectBase MakeNew(AlphaDesc dataArea, AlphaDesc grfa,
            KeyValuePair<String, Object>[] joinedObjects)
        {
            var new<StructureNoplural> = new <StructureNoplural>(dataArea, grfa);
<IF DEFINED_ENABLE_RELATIONS>
  <IF STRUCTURE_RELATIONS>
            foreach (var joinedObject in joinedObjects)
            {
                switch (joinedObject.Key)
                {
    <RELATION_LOOP_RESTRICTED>
;//    
      <IF MANY_TO_ONE_TO_MANY>
                case "<HARMONYCORE_RELATION_NAME>":
                    new<StructureNoplural>.<HARMONYCORE_RELATION_NAME> = (<RelationTostructureNoplural>)joinedObject.Value;
                    break;
      </IF MANY_TO_ONE_TO_MANY>
;//      
      <IF ONE_TO_ONE>
                case "<HARMONYCORE_RELATION_NAME>":
                    new<StructureNoplural>.<HARMONYCORE_RELATION_NAME> = (<RelationTostructureNoplural>)joinedObject.Value;
                    break;
      </IF ONE_TO_ONE>
;//      
      <IF ONE_TO_MANY_TO_ONE>
                case "<HARMONYCORE_RELATION_NAME>":
                    new<StructureNoplural>.<HARMONYCORE_RELATION_NAME> = (ICollection<<RelationTostructureNoplural>>)joinedObject.Value;
                    break;
      </IF ONE_TO_MANY_TO_ONE>
;//      
      <IF ONE_TO_MANY>
                case "<HARMONYCORE_RELATION_NAME>":
                    new<StructureNoplural>.<HARMONYCORE_RELATION_NAME> = (ICollection<<RelationTostructureNoplural>>)joinedObject.Value;
                    break;
      </IF ONE_TO_MANY>
;//      
    </RELATION_LOOP_RESTRICTED>
                }
            }
  </IF STRUCTURE_RELATIONS>
</IF DEFINED_ENABLE_RELATIONS>

            return new<StructureNoplural>;

        }

        ///<summary>
        /// Provide a partial method to allow for initialization of custom fields.
        ///</summary>
        partial void InitializeCustomFields();

    }

}