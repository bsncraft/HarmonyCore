<CODEGEN_FILENAME><StructureNoplural>.cs</CODEGEN_FILENAME>
<REQUIRES_CODEGEN_VERSION>5.4.6</REQUIRES_CODEGEN_VERSION>
;//****************************************************************************
;//
;// Title:       ODataModel.tpl
;//
;// Type:        CodeGen Template
;//
;// Description: Template to define structure based Data Object with CLR types
;//
;// Copyright (c) 2012, Synergex International, Inc. All rights reserved.
;//
;// Redistribution and use in source and binary forms, with or without
;// modification, are permitted provided that the following conditions are met:
;//
;// * Redistributions of source code must retain the above copyright notice,
;//   this list of conditions and the following disclaimer.
;//
;// * Redistributions in binary form must reproduce the above copyright notice,
;//   this list of conditions and the following disclaimer in the documentation
;//   and/or other materials provided with the distribution.
;//
;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;// POSSIBILITY OF SUCH DAMAGE.
;//
//*****************************************************************************
//
// Title:       <StructureNoplural>.cs
//
// Description: Data model representing data defined by the repository
//              structure <STRUCTURE_NOALIAS><IF STRUCTURE_FILES> and from the data file <FILE_NAME></IF STRUCTURE_FILES>.
//
//*****************************************************************************
// WARNING: GENERATED CODE!
// This file was generated by CodeGen. Avoid editing the file if possible.
// Any changes you make will be lost of the file is re-generated.
//*****************************************************************************

using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Text;
using Harmony.Core;
using Harmony.Core.Converters;
<IF DEFINED_ENABLE_FIELD_SECURITY>
using Harmony.OData;
</IF DEFINED_ENABLE_FIELD_SECURITY>
using Harmony.Core.Context;
using Harmony.Core.FileIO;
using Microsoft.Extensions.DependencyInjection;
using Synergex.SynergyDE;

namespace <NAMESPACE>
{
    public partial class <StructureNoplural> : Dbl.<StructureNoplural>Base
    {
        private static <StructureNoplural>Metadata sMetadata;

        #region Constructors

        static <StructureNoplural>()
        {
            sMetadata = new <StructureNoplural>Metadata();
            DataObjectMetadataBase.MetadataLookup.TryAdd(typeof(<StructureNoplural>), sMetadata);
        }

        /// <summary>
        ///  Constructor, initialise the base fields
        /// </summary>
        public <StructureNoplural>() : base()
        {

        }

        /// <summary>
        ///  Alternate Constructor, accepts the structured data
        /// </summary>
        public <StructureNoplural>(AlphaDesc inData, AlphaDesc inGrfa) : base(inData, inGrfa)
        {
            
        }

        #endregion

        #region Attributes of this entity

<IF STRUCTURE_RELATIVE>
        /// <summary>
        /// Record number
        /// </summary>
        public int RecordNumber { get; set; }

</IF STRUCTURE_RELATIVE>
<COUNTER_1_RESET>
<FIELD_LOOP>
  <IF USER>
  <ELSE>
    <IF CUSTOM_NOT_HARMONY_EXCLUDE>
        /// <summary>
        /// <FIELD_DESC>
        /// </summary>
      <IF ONLY_PKSEGMENT>
        [Key]
      </IF ONLY_PKSEGMENT>
      <IF REQUIRED>
        [Required(ErrorMessage="<FIELD_DESC> is required. ")]
      </IF REQUIRED>
      <IF HARMONYCORE_CUSTOM_FIELD_DATATYPE>
      <ELSE>
        <IF ALPHA>
        [StringLength(<FIELD_SIZE>, ErrorMessage="<FIELD_DESC> cannot exceed <FIELD_SIZE> characters. ")]
        </IF ALPHA>
        <IF DECIMAL>
          <IF CUSTOM_NOT_HARMONY_AS_STRING>
        [Range(<FIELD_MINVALUE>,<FIELD_MAXVALUE>, ErrorMessage="<FIELD_DESC> must be between <FIELD_MINVALUE> and <FIELD_MAXVALUE>. ")]
          </IF CUSTOM_NOT_HARMONY_AS_STRING>
        </IF DECIMAL>
        <IF INTEGER>
        [Range(<FIELD_MINVALUE>,<FIELD_MAXVALUE>, ErrorMessage="<FIELD_DESC> must be between <FIELD_MINVALUE> and <FIELD_MAXVALUE>. ")]
        </IF INTEGER>
      </IF HARMONYCORE_CUSTOM_FIELD_DATATYPE>
      <IF DEFINED_ENABLE_FIELD_SECURITY>
        <IF CUSTOM_HARMONY_AUTHENTICATE>
        [AuthorizeField]
        </IF CUSTOM_HARMONY_AUTHENTICATE>
        <IF HARMONY_ROLES>
        [AuthorizeField("<HARMONY_ROLES>")]
        </IF HARMONY_ROLES>
      </IF DEFINED_ENABLE_FIELD_SECURITY>
      <COUNTER_1_INCREMENT>
      <IF CUSTOM_HARMONY_AS_STRING>
        public string <FieldSqlname>
      <ELSE>
        public <HARMONYCORE_FIELD_DATATYPE> <FieldSqlname>        
      </IF CUSTOM_HARMONY_AS_STRING>
        {
      <IF HARMONYCORE_CUSTOM_FIELD>
            get => <HARMONYCORE_CUSTOM_FIELD_TYPE>Converter.Convert(Sd<FieldSqlname>);
      <ELSE>
        <IF ALPHA>
            get => Converters.GetString(Sd<FieldSqlname>);
        </IF ALPHA>
        <IF DATE>
          <IF CUSTOM_HARMONY_AS_STRING>
            get => Converters.GetInt(Sd<FieldSqlname>).ToString("XXXX-XX-XX");
          <ELSE>
            <IF DATE_YYMMDD>
           get => Converters.GetDate(Sd<FieldSqlname>, null, "YYMMDD");
            <ELSE>
              <IF DATE_YYYYJJJ>
           get => Converters.GetDate(Sd<FieldSqlname>, null, "YYYYJJJ");
              <ELSE>
           get => Converters.GetDate(Sd<FieldSqlname>, null, "YYYYMMDD");
              </IF DATE_YYYYJJJ>
            </IF DATE_YYMMDD>
          </IF CUSTOM_HARMONY_AS_STRING>
        </IF DATE>
        <IF TIME_HHMM>
          <IF CUSTOM_HARMONY_AS_STRING>
            get => Sd<FieldSqlname>.ToString("XX:XX");
          <ELSE>
            get => Convert.ToDateTime(Sd<FieldSqlname>.ToString("XX:XX"));
          </IF CUSTOM_HARMONY_AS_STRING>
        </IF TIME_HHMM>
        <IF TIME_HHMMSS>
          <IF CUSTOM_HARMONY_AS_STRING>
            get => Sd<FieldSqlname>.ToString("XX:XX:XX");
          <ELSE>
            get => Convert.ToDateTime(Sd<FieldSqlname>.ToString("XX:XX:XX"));
          </IF CUSTOM_HARMONY_AS_STRING>
        </IF TIME_HHMMSS>
        <IF DECIMAL>
          <IF CUSTOM_HARMONY_AS_STRING>
            <IF PRECISION>
            get => Converters.GetDecimal(Sd<FieldSqlname>, null, "DECIMALPLACES#<FIELD_PRECISION>").ToString("<FIELD_FORMATSTRING>");
            <ELSE>
            get => Sd<FieldSqlname>.ToString("<FIELD_FORMATSTRING>");
            </IF PRECISION>
          <ELSE>
            <IF PRECISION>
            get => Converters.GetDecimal(Sd<FieldSqlname>, null, "DECIMALPLACES#<FIELD_PRECISION>");
            <ELSE>
            get => (<FIELD_SNTYPE>)Sd<FieldSqlname>;
            </IF PRECISION>
          </IF CUSTOM_HARMONY_AS_STRING>
        </IF DECIMAL>
        <IF INTEGER>
            get => Converters.GetInt(Sd<FieldSqlname>);
        </IF INTEGER>
        <IF BOOLEAN>
            get => Convert.ToBoolean(Sd<FieldSqlname>);
        </IF BOOLEAN>
        <IF AUTO_SEQUENCE>
            get => (<FIELD_SNTYPE>)Sd<FieldSqlname>;    //Todo: confirm
        </IF AUTO_SEQUENCE>
        <IF AUTO_TIMESTAMP>
            get => (<FIELD_SNTYPE>)Sd<FieldSqlname>;    //Todo: confirm
        </IF AUTO_TIMESTAMP>
      </IF HARMONYCORE_CUSTOM_FIELD>            
      <IF DEFINED_ENABLE_READ_ONLY_PROPERTIES>
        <IF READONLY>
            set => throw new ApplicationException("Property <FieldSqlname> is read only!");
        </IF READONLY>
      </IF DEFINED_ENABLE_READ_ONLY_PROPERTIES>
      <IF HARMONYCORE_CUSTOM_FIELD>
            set => Sd<FieldSqlname> = <HARMONYCORE_CUSTOM_FIELD_TYPE>Converter.ConvertBack(value);
      <ELSE>
        <IF ALPHA>
            set => Sd<FieldSqlname> = Converters.GetA(value<IF UPPERCASE>.ToUpper()</IF UPPERCASE>);
        </IF ALPHA>
        <IF DATE>
          <IF CUSTOM_HARMONY_AS_STRING>
            set => Sd<FieldSqlname> = Converters.GetDateD(value, null, "XXXX-XX-XX").ToString();
          <ELSE>
            <IF DATE_YYMMDD>
           set => Sd<FieldSqlname> = Converters.GetDateD(value, null, "YYMMDD");
            <ELSE>
              <IF DATE_YYYYJJJ>
           set => Sd<FieldSqlname> = Converters.GetDateD(value, null, "YYYYJJJ");
              <ELSE>
           set => Sd<FieldSqlname> = Converters.GetDateD(value, null, "YYYYMMDD");
              </IF DATE_YYYYJJJ>
            </IF DATE_YYMMDD>
          </IF CUSTOM_HARMONY_AS_STRING>
        </IF DATE>
        <IF TIME_HHMM>
          <IF CUSTOM_HARMONY_AS_STRING>
            set => Sd<FieldSqlname> = Converters.GetD(value,"XX:XX");
          <ELSE>
            set => Sd<FieldSqlname> = (value.Hour * 100) + value.Minute;
          </IF CUSTOM_HARMONY_AS_STRING>
        </IF TIME_HHMM>
        <IF TIME_HHMMSS>
          <IF CUSTOM_HARMONY_AS_STRING>
            set => Sd<FieldSqlname> = Converters.GetD(value,"XX:XX:XX");
          <ELSE>
            set => Sd<FieldSqlname> = (value.Hour * 10000) + (value.Minute * 100) + value.Second;
          </IF CUSTOM_HARMONY_AS_STRING>
        </IF TIME_HHMMSS>
        <IF DECIMAL>
          <IF CUSTOM_HARMONY_AS_STRING>
            <IF PRECISION>
            set => Sd<FieldSqlname> = Converters.GetId(value, null, "<FIELD_FORMATSTRING>");
            <ELSE>
            set => Sd<FieldSqlname> = Converters.GetD(value,"<FIELD_FORMATSTRING>");
            </IF PRECISION>
          <ELSE>
            set => Sd<FieldSqlname> = Converters.GetD(value);
          </IF CUSTOM_HARMONY_AS_STRING>
        </IF DECIMAL>
        <IF INTEGER>
            set => Sd<FieldSqlname> = Converters.GetI(value);
        </IF INTEGER>
        <IF BOOLEAN>
            set => Sd<FieldSqlname> = Converters.GetD(value);   //Todo: confirm
        </IF BOOLEAN>
        <IF AUTO_SEQUENCE>
            set => Sd<FieldSqlname> = value;    //Todo: confirm
        </IF AUTO_SEQUENCE>
        <IF AUTO_TIMESTAMP>
            set => Sd<FieldSqlname> = value;    //Todo: confirm 
        </IF AUTO_TIMESTAMP>
      </IF HARMONYCORE_CUSTOM_FIELD>
        }

    </IF CUSTOM_NOT_HARMONY_EXCLUDE>
  </IF USER>
</FIELD_LOOP>
        #endregion

        #region Public methods

<IF DEFINED_ENABLE_RELATIONS>
  <IF STRUCTURE_RELATIONS>
    <RELATION_LOOP_RESTRICTED>
      <IF REQUIRES_MATCH>
            protected override void relFromKeyValidate<RelationTostructureNoplural>(IDataObjectProvider doProvider, 
                NumericParam keyNumber, AlphaDesc rel<RELATION_NUMBER>FromKey)
            {
                using var rel<RELATION_NUMBER>FileIO = doProvider.GetFileIO<<RelationTostructureNoplural>>();
                if (rel<RELATION_NUMBER>FileIO.FindRecord(keyNumber, rel<RELATION_NUMBER>FromKey) != FileAccessResults.Success)
                    throw new ValidationException("Invalid data for relation <HARMONYCORE_RELATION_NAME>");
            }
      </IF REQUIRES_MATCH>
    </RELATION_LOOP_RESTRICTED>
  </IF STRUCTURE_RELATIONS>
</IF DEFINED_ENABLE_RELATIONS>

        #endregion

        #region Other attributes

        /// <summary>
        /// Metadata describing the public field properties
        /// </summary>
        public override DataObjectMetadataBase Metadata => sMetadata;

        #endregion

        <IF DEFINED_ENABLE_RELATIONS>
          <IF STRUCTURE_RELATIONS>

        #region Relationships to other entities

            <RELATION_LOOP_RESTRICTED>
              <COUNTER_1_INCREMENT>
;// A
              <IF MANY_TO_ONE_TO_MANY>
        /// <summary>
        /// Relationship (Type A)
        /// <STRUCTURE_NOPLURAL>.<RELATION_FROMKEY> (one) --> (one) --> (many) <RELATION_TOSTRUCTURE_NOPLURAL>.<RELATION_TOKEY>
        /// </summary>
        public <RelationTostructureNoplural> <HARMONYCORE_RELATION_NAME> { get; set; }
              </IF MANY_TO_ONE_TO_MANY>
;// B
              <IF ONE_TO_ONE_TO_ONE>
        /// <summary>
        /// Relationship (Type B)
        /// <STRUCTURE_NOPLURAL>.<RELATION_FROMKEY> (one) --> (one) --> (one) <RELATION_TOSTRUCTURE_NOPLURAL>.<RELATION_TOKEY>
        /// </summary>
        public <RelationTostructureNoplural> <HARMONYCORE_RELATION_NAME> { get; set; }
              </IF ONE_TO_ONE_TO_ONE>
;// C
              <IF ONE_TO_ONE>
        /// <summary>
        /// Relationship (Type C)
        /// <STRUCTURE_NOPLURAL>.<RELATION_FROMKEY> (one) --> (one) <RELATION_TOSTRUCTURE_NOPLURAL>.<RELATION_TOKEY>
        /// </summary>
        public <RelationTostructureNoplural> <HARMONYCORE_RELATION_NAME> { get; set; }
              </IF ONE_TO_ONE>
;// D
              <IF ONE_TO_MANY_TO_ONE>
        /// <summary>
        /// Relationship (Type D)
        /// <STRUCTURE_NOPLURAL>.<RELATION_FROMKEY> (one) <-> (many) <RELATION_TOSTRUCTURE_NOPLURAL>.<RELATION_TOKEY>
        /// </summary>
        public ICollection<<RelationTostructureNoplural>> <HARMONYCORE_RELATION_NAME> { get; set; }
              </IF ONE_TO_MANY_TO_ONE>
;// E
              <IF ONE_TO_MANY>
        /// <summary>
        /// Relationship (Type E)
        /// <STRUCTURE_NOPLURAL>.<RELATION_FROMKEY> (one) --> (many) <RELATION_TOSTRUCTURE_NOPLURAL>.<RELATION_TOKEY>
        /// </summary>
        public ICollection<<RelationTostructureNoplural>> <HARMONYCORE_RELATION_NAME> { get; set; }
              </IF ONE_TO_MANY>
            </RELATION_LOOP_RESTRICTED>
        #endregion

            <COUNTER_2_RESET>
            <RELATION_LOOP_RESTRICTED>
              <COUNTER_1_RESET>
              <FROM_KEY_SEGMENT_LOOP>
                <IF SEG_TYPE_LITERAL>
                  <COUNTER_2_INCREMENT>
                    <IF COUNTER_2_EQ_1>

        #region "Properties to represent literal key segments"

                    </IF COUNTER_2_EQ_1>
        public readonly property <RelationFromkey>Literal<COUNTER_1_INCREMENT><COUNTER_1_VALUE>, <LITERAL_SEGMENT_SNTYPE>, <LITERAL_SEGMENT_VALUE>
        private _<RelationFromkey>Literal<COUNTER_1_VALUE>, <LITERAL_SEGMENT_SNTYPE>, <LITERAL_SEGMENT_VALUE>
                </IF SEG_TYPE_LITERAL>
              </FROM_KEY_SEGMENT_LOOP>
            </RELATION_LOOP_RESTRICTED>
            <IF COUNTER_2_GT_0>

        #endregion

            </IF COUNTER_2_GT_0>
          </IF STRUCTURE_RELATIONS>
        </IF DEFINED_ENABLE_RELATIONS>

        <IF STRUCTURE_FILES>
        #region Properties to represent keys
        
        <IF STRUCTURE_ISAM>
          <KEY_LOOP>
            <IF FIRST>
        //Access keys

            </IF FIRST>
        private string _KEY_<KEY_NAME> = "";
        public string KEY_<KEY_NAME> { get => _KEY_<KEY_NAME>; }

          </KEY_LOOP>
          <FOREIGN_KEY_LOOP>
            <IF FIRST>
        //Foreign keys

            </IF FIRST>
        private string _KEY_<KEY_NAME> = "";
        public string KEY_<KEY_NAME> { get => _KEY_<KEY_NAME>; }
          </FOREIGN_KEY_LOOP>

        </IF STRUCTURE_ISAM>
        #endregion

</IF STRUCTURE_FILES>
    }

}
